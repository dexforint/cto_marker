# Модуль утилитарных функций для работы с изображениями
# Содержит функции для анализа изображений и определения пустых страниц

from PIL import Image
import numpy as np
import cv2
from typing import List, Optional

def is_blank_image(image: Image.Image, polygon: Optional[List[List[int]]] = None) -> bool:
    """
    Определяет, является ли изображение пустым или содержит ли оно значимый контент.
    
    Функция выполняет комплексный анализ изображения для определения наличия текста,
    графических элементов или других значимых данных. Использует алгоритмы
    компьютерного зрения для анализа структуры изображения.
    
    Алгоритм анализа:
    1. Проверка базовых характеристик (размер, пустота)
    2. Валидация полигона (если указан)
    3. Конвертация в оттенки серого
    4. Применение размытия по Гауссу для шумоподавления
    5. Адаптивная бинаризация для выделения текста/элементов
    6. Анализ связных компонент для подсчета значимых элементов
    7. Морфологические операции для очистки шума
    8. Финальная оценка наличия контента
    
    Аргументы:
        image: PIL изображение для анализа
        polygon: Опциональный список координат полигона для анализа части изображения
    
    Возвращает:
        bool: True если изображение считается пустым, False если содержит контент
    """
    # Преобразуем PIL изображение в numpy массив для обработки
    image = np.asarray(image)
    
    # Базовая проверка на пустоту изображения
    if (
        image is None
        or image.size == 0
        or image.shape[0] == 0
        or image.shape[1] == 0
    ):
        # Обрабатываем случай с пустым изображением
        return True

    # Проверяем валидность полигона, если он указан
    if polygon is not None:
        # Округляем координаты полигона до целых чисел
        rounded_polys = [[int(corner[0]), int(corner[1])] for corner in polygon]
        # Проверяем, является ли полигон вырожденным (все вершины совпадают)
        if rounded_polys[0] == rounded_polys[1] and rounded_polys[2] == rounded_polys[3]:
            return True

    # Конвертируем изображение из RGB в оттенки серого
    # Это упрощает анализ и уменьшает количество каналов для обработки
    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    
    # Применяем размытие по Гауссу для сглаживания и шумоподавления
    # Размер ядра 7x7 обеспечивает хорошее сглаживание текста
    gray = cv2.GaussianBlur(gray, (7, 7), 0)

    # Адаптивная бинаризация (инверсная для текста как белого)
    # Используется для выделения текстовых и графических элементов на белом фоне
    binarized = cv2.adaptiveThreshold(
        gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 31, 15
    )

    # Находим связные компоненты в бинаризованном изображении
    # Это помогает идентифицировать отдельные текстовые блоки или элементы
    num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(
        binarized, connectivity=8
    )
    
    # Создаем очищенное изображение, содержащее только значимые компоненты
    cleaned = np.zeros_like(binarized)
    for i in range(1, num_labels):  # пропускаем фон (компонент 0)
        cleaned[labels == i] = 255

    # Создаем структурирующий элемент для морфологических операций
    # Размер 1x5 эффективен для объединения отдельных символов в слова
    kernel = np.ones((1, 5), np.uint8)
    
    # Применяем дилатацию для объединения близко расположенных элементов
    # Это помогает объединить отдельные символы в слова/строки
    dilated = cv2.dilate(cleaned, kernel, iterations=3)
    
    # Нормализуем изображение и подсчитываем количество белых пикселей
    b = dilated / 255
    # Если сумма всех пикселей равна 0, изображение считается пустым
    return bool(b.sum() == 0)